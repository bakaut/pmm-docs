Конечно, вот тезисное архитектурное описание того, что делает этот скрипт.

### Архитектурное описание скрипта (тезисно)

Это бэкенд для Telegram-бота, реализованный как серверная функция (вероятно, для Yandex Cloud Functions). Бот представляет собой AI-собеседника с предопределенной ролью и поведением.

#### Ключевые компоненты и логика:

1.  **Конфигурация и Инициализация:**
    * **Системный Промпт (`system_prompt`):** Жестко задает личность, роль, правила и логику поведения AI-ассистента ("Пой Мой Мир"). Он определяет формат ответов (песня), тон общения и запретные темы.
    * **Переменные окружения:** Все критически важные параметры (токены, ключи API, адреса баз данных) загружаются из окружения, что делает приложение гибким для развертывания.
    * **"Холодный старт":** При первом запуске скрипт инициализирует HTTP-клиент с политикой повторных запросов (retry) для надежности, настраивает логирование и проверяет наличие основных переменных.

2.  **Точка входа (`handler`):**
    * Основная функция, которая обрабатывает входящие HTTP-запросы (вебхуки от Telegram).
    * Извлекает сообщение и данные о пользователе и чате.
    * Аутентифицирует пользователя и сессию в системе.
    * **Главный рабочий процесс:**
        1.  Найти или создать пользователя в базе данных.
        2.  Проверить, не заблокирован ли пользователь.
        3.  Получить или создать активную сессию диалога.
        4.  Загрузить историю сообщений для этой сессии.
        5.  Сохранить новое сообщение от пользователя.
        6.  Сформировать контекст для AI (системный промпт + история).
        7.  Вызвать языковую модель (LLM) через API.
        8.  Обработать ответ AI, включая возможные вызовы инструментов (например, модерации).
        9.  Сохранить ответ AI в историю.
        10. Отправить ответ пользователю в Telegram.

3.  **Двухуровневая система хранения данных:**
    * **Yandex Database (YDB) - Горячий кэш:**
        * **Роль:** Быстрое хранилище для *недавних* сообщений в активной сессии.
        * **Цель:** Ускорить получение истории сообщений и снизить нагрузку на основную базу данных во время активного диалога.
        * **Механизм `flush`:** Когда количество сообщений в кэше достигает лимита (`cache_limit`), они пакетом записываются в постоянное хранилище (PostgreSQL), после чего кэш для этой сессии очищается.
    * **PostgreSQL - Постоянное хранилище:**
        * **Роль:** Основная, долгосрочная база данных.
        * **Данные:** Хранит всю информацию о пользователях, ботах, сессиях, полную историю всех диалогов и логи модерации.

4.  **Взаимодействие с LLM (AI-моделью):**
    * Использует **OpenRouter** как шлюз, что позволяет гибко переключаться между разными языковыми моделями.
    * Передает модели полный контекст: системный промпт, историю диалога и новое сообщение.
    * Поддерживает **Tool Use**: AI может запросить выполнение предопределенной функции на стороне бэкенда (`moderate_user`), передав ей необходимые аргументы (например, `chat_id`, `user_id`).

5.  **Многоуровневая система модерации:**
    * **Уровень промпта:** Жесткие запреты встроены в `system_prompt`.
    * **Уровень AI:** Модель обучена вызывать функцию `moderate_user` при нарушении правил пользователем.
    * **Внешний API:** Используется `OpenAI Moderation API` для дополнительной проверки текста на недопустимый контент.
    * **Внутренняя логика:** Скрипт ведет подсчет предупреждений для каждого пользователя в PostgreSQL. На основе числа предупреждений применяется наказание (временный или постоянный бан).

6.  **Вспомогательные модули:**
    * **Telegram Helpers:** Набор функций для удобной работы с Telegram Bot API (отправка сообщений, экранирование символов, разделение длинных текстов).
    * **Database Helpers:** Абстракции для упрощения выполнения SQL-запросов к PostgreSQL.
    * **Logging:** Централизованная система логирования, отформатированная для Yandex Cloud.
